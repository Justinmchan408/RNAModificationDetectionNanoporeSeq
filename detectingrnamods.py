# -*- coding: utf-8 -*-
"""DetectingRNAMods.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gM7M2sf9F3YbrStoemXYsoR2EbyAVWOG
"""

from google.colab import drive

# Load the data - If using Google drive link to access data the following with connect
# to drive, authenticate using your Google account and load the data

!pip install -U -q PyDrive ## you will have install for every colab session

from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials

# 1. Authenticate and create the PyDrive client.
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

# Direct RNA (GM12878): https://drive.google.com/file/d/1KTfPsAbLvzlC-Wv3DatTPWJo7uhVEDPT/view?usp=sharing
# IVT Data: https://drive.google.com/file/d/1u-om1NRtcCOTzHQISc03wx7gS909d456/view?usp=sharing
# PsuedoUPositions: https://drive.google.com/file/d/1Vv_4vVI3a5w0-AEymiUyFB9JIk13Y0mQ/view?usp=sharing
# ALL PsuedoUPositions: https://drive.google.com/file/d/1Eswfw-6nemFeOFoSr7SOn5RmsKhBHfYq/view?usp=sharing


# 2. Now proxy the Google Drive files to a local file
directRNAimport = drive.CreateFile({'id':'1KTfPsAbLvzlC-Wv3DatTPWJo7uhVEDPT'})
IVTimport = drive.CreateFile({'id':'1u-om1NRtcCOTzHQISc03wx7gS909d456'})
pseudoUposimport = drive.CreateFile({'id':'1Vv_4vVI3a5w0-AEymiUyFB9JIk13Y0mQ'})
ALLpseudoUposimport = drive.CreateFile({'id':'1Eswfw-6nemFeOFoSr7SOn5RmsKhBHfYq'})

directRNAimport.GetContentFile('reads-ref.eventalign.txt') # reads-ref.eventalign.txt is the file name that will be accessible in the notebook.
IVTimport.GetContentFile('reads-ref.NewIVT.eventalign.txt') # reads-ref.NewIVT.eventalign.txt is the file name that will be accessible in the notebook.
pseudoUposimport.GetContentFile('pseudoUpositions.txt')
ALLpseudoUposimport.GetContentFile('allMotifpseudoUpositions.txt')

import pandas as pd
import numpy as np

# Creates a dataframe with the direct RNA dataset
dfDirect = pd.read_csv("reads-ref.eventalign.txt", delimiter= "\t")
dfDirect.head(5)

# Creates a dataframe with the IVT dataset
dfIVT = pd.read_csv("reads-ref.NewIVT.eventalign.txt", delimiter= "\t")
dfIVT.head(5)

# Prints size of both datasets:
# Direct RNA
# IVT
print(dfDirect.index)
print(dfIVT.index)

# Shrink the dataset to the first 100000 points/datapoints
dfDirect = dfDirect.iloc[:100000]
dfIVT = dfIVT.iloc[:100000]
'''
indexDirectNames = dfDirect[dfDirect['model_mean'] == 0.00].index
indexIVTNames = dfIVT[dfIVT['model_mean'] == 0.00].index

dfDirect.drop(indexDirectNames, inplace = True)
dfIVT.drop(indexIVTNames, inplace = True)
'''
# Check size
print(dfDirect.index)
print(dfIVT.index)

# Creating a 5-mer dictionaries for Direct RNA and IVT data with event_level_mean (current levels)
import itertools

rnaMotifDict = {'NaN': []}
ivtDict = {'NaN': []}

a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    rnaMotifDict[''.join(eachMotif)] = []
    ivtDict[''.join(eachMotif)] = []

for index in range(len(dfDirect)):
    if isinstance(dfDirect['reference_kmer'][index], str) and len(dfDirect['reference_kmer'][index]) == 5 and dfDirect['model_mean'][index] != 0.00:
        rnaMotifDict[dfDirect['reference_kmer'][index]].append(dfDirect['event_level_mean'][index])
    if isinstance(dfIVT['reference_kmer'][index], str) and len(dfIVT['reference_kmer'][index]) == 5 and dfIVT['model_mean'][index] != 0.00:
        ivtDict[dfIVT['reference_kmer'][index]].append(dfIVT['event_level_mean'][index])

print("Direct RNA current values:")
print(rnaMotifDict)
print("IVT current values:")
print(ivtDict)

# Let us see which 5-mer from the direct RNA data has the greatest amount of data by ordering them
motifData = []
motifDataDictionary = dict()
for eachMotif, currentVals in rnaMotifDict.items():
    motifData.append([eachMotif, len(currentVals)])
    motifDataDictionary[eachMotif] = len(currentVals)
motifData.sort(key = lambda x: x[1], reverse=True)
print(motifData)

# Create KMeans model
from sklearn.cluster import KMeans

km = KMeans(n_clusters = 2)
exampleNumpy = np.asarray(rnaMotifDict.get("TGCTC")).reshape(-1,1)
y_predicted = km.fit_predict(exampleNumpy)
print(y_predicted)

# Create Sum of Squared Error graph to find clusters that should be used
import matplotlib.pyplot as plt
sse = []
for k in range(1, 10):
    km = KMeans(n_clusters = k)
    km.fit(exampleNumpy)
    sse.append(km.inertia_)

print(sse)
plt.title('Sum of Squared Error vs Clusters')
plt.xlabel('Clusters')
plt.ylabel('Sum of squared error')
plt.plot(range(1,10), sse)
plt.show()

dfMotifAAAAA = dfDirect[dfDirect['reference_kmer'] == 'AAAAA']
dfMotifAAAAA = dfMotifAAAAA[dfMotifAAAAA['model_kmer'] != 'NNNNN']
# Create Cluster Model, KMeans with AAAAA motif
km = KMeans(n_clusters = 2)
dfMotifAAAAA["cluster"] = km.fit_predict(dfMotifAAAAA[['event_level_mean']])
dfMotifAAAAA.head(len(dfMotifAAAAA))

# Create Classification method, Logistic Regression

listOfClusterVals = list(dfMotifAAAAA['cluster'])
actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)

from sklearn import preprocessing, datasets, linear_model
logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
logModel.fit(dfMotifAAAAA[['event_level_mean']], dfMotifAAAAA['cluster'])

dfIVTMotifAAAAA = dfIVT[dfIVT['reference_kmer'] == 'AAAAA']
dfIVTMotifAAAAA.head(len(dfIVTMotifAAAAA))

predictedVals = list(logModel.predict(dfIVTMotifAAAAA[['event_level_mean']]))
print("Accuracy: " + str(predictedVals.count(actualIVTVal)/len(predictedVals)))

# Method for creating clustering/classification for each kmer

def kmerPredictionAccuracy(directRNADataFrame, ivtDataFrame):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            km = KMeans(n_clusters = 2)
            dfDirectMotif["cluster"] = km.fit_predict(dfDirectMotif[['event_level_mean']])

            listOfClusterVals = list(dfDirectMotif['cluster'])
            actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)

            logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
            logModel.fit(dfDirectMotif[['event_level_mean']], dfDirectMotif['cluster'])

            predictedVals = list(logModel.predict(dfIVTMotif[['event_level_mean']]))
            motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

from statistics import mean
pd.options.mode.chained_assignment = None # To not get warning message

accuracyDict = kmerPredictionAccuracy(dfDirect, dfIVT)
print(accuracyDict)
dataModelAccuracies = [val for val in accuracyDict.values() if val >= 0]
print(mean(dataModelAccuracies))

# Plot Accuracy Graph among 5-mers
import matplotlib.pyplot as plt

dataModelAccuracies = [val for val in accuracyDict.values() if val >= 0]
n, bins, patches = plt.hist(dataModelAccuracies, 10)
plt.title("Accuracy Distribution for Kmer of Current Model")
plt.ylabel("Kmer Accuracy Counts")
plt.xlabel("Kmer Accuracies")
plt.show()

from sklearn.utils.testing import ignore_warnings
from sklearn.exceptions import ConvergenceWarning

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracy(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            km = KMeans(n_clusters = 2)
            dfDirectMotif["cluster"] = km.fit_predict(dfDirectMotif[category])

            if len(set(dfDirectMotif['cluster'])) > 1:
                listOfClusterVals = list(dfDirectMotif['cluster'])
                actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)

                logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
                logModel.fit(dfDirectMotif[category], dfDirectMotif['cluster'])

                predictedVals = list(logModel.predict(dfIVTMotif[category]))
                motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            else:
                motifAccuracyModelDict[currentMotif] = -1  
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

# Creates a list of the categories (excluding ID and class)
categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracy(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

from statistics import mean
for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracy(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))
n, bins, patches = plt.hist(dataModelAccuracies, 10)
plt.show()

# Mean Shift
from sklearn.cluster import MeanShift

# Testing with 5mer
dfCCCCC = dfDirect[dfDirect['reference_kmer'] == 'AAAAA']
dfCCCCC = dfCCCCC[dfCCCCC['model_kmer'] != 'NNNNN']

meanShift = MeanShift(bin_seeding=True)
dfCCCCC['cluster'] = meanShift.fit_predict(dfCCCCC[['event_level_mean']])

clusterList = list(dfCCCCC['cluster'])
noModCluster = max(clusterList, key = clusterList.count)

logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
logModel.fit(dfCCCCC[['event_level_mean']], dfCCCCC['cluster'])

dfIVTCCCCC = dfIVT[dfIVT['reference_kmer'] == 'AAAAA']
dfIVTCCCCC = dfIVTCCCCC[dfIVTCCCCC['model_kmer'] != 'NNNNN']

predictedVals = list(logModel.predict(dfIVTCCCCC[['event_level_mean']]))
print("Accuracy: " + str(predictedVals.count(noModCluster)/len(predictedVals)))

from sklearn.utils.testing import ignore_warnings
from sklearn.exceptions import ConvergenceWarning

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyMeanShift(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            meansShift = MeanShift(bandwidth=1.0)
            dfDirectMotif["cluster"] = meansShift.fit_predict(dfDirectMotif[category])

            if len(set(dfDirectMotif['cluster'])) == 2:
                listOfClusterVals = list(dfDirectMotif['cluster'])
                actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)

                logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
                logModel.fit(dfDirectMotif[category], dfDirectMotif['cluster'])

                predictedVals = list(logModel.predict(dfIVTMotif[category]))
                motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            else:
                motifAccuracyModelDict[currentMotif] = -1  
        else:
            motifAccuracyModelDict[currentMotif] = -2
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyMeanShift(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyMeanShift(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))

from sklearn.cluster import DBSCAN

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyDBSCAN(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            dbscanCluster = DBSCAN(eps=0.25, min_samples=10)
            dfDirectMotif["cluster"] = dbscanCluster.fit_predict(dfDirectMotif[category])

            if len(set(dfDirectMotif['cluster'])) == 2:
                listOfClusterVals = list(dfDirectMotif['cluster'])
                actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)

                logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
                logModel.fit(dfDirectMotif[category], dfDirectMotif['cluster'])

                predictedVals = list(logModel.predict(dfIVTMotif[category]))
                motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            else:
                motifAccuracyModelDict[currentMotif] = -1  
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyDBSCAN(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyDBSCAN(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))

from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyKMeansPrediction(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            km = KMeans(n_clusters = 2)
            dfDirectMotif["cluster"] = km.fit_predict(dfDirectMotif[category])

            #if len(set(dfDirectMotif['cluster'])) > 0:
            listOfClusterVals = list(dfDirectMotif['cluster'])
            actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)

            #logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
            #logModel.fit(dfDirectMotif[category], dfDirectMotif['cluster'])
            '''
            scalar = StandardScaler()
            X_train = list(dfDirectMotif[category])
            scalar.fit(X_train)
            X_train = scalar.transform(X_train)
            X_test = scalar.transform(list(dfIVTMotif[category]))
            '''
                
            classifer = KNeighborsClassifier(n_neighbors=2)
            classifer.fit(dfDirectMotif[category], dfDirectMotif['cluster'])


            predictedVals = list(classifer.predict(dfIVTMotif[category]))
            motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            #else:
            #   motifAccuracyModelDict[currentMotif] = -1  
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyKMeansPrediction(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyKMeansPrediction(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyMeanShift2(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            meansShift = MeanShift(bandwidth=1.0)
            dfDirectMotif["cluster"] = meansShift.fit_predict(dfDirectMotif[category])

            #if len(set(dfDirectMotif['cluster'])) > 0:
            listOfClusterVals = list(dfDirectMotif['cluster'])
            actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)

            #logModel = linear_model.LogisticRegression(solver = "liblinear", class_weight = "balanced")
            #logModel.fit(dfDirectMotif[category], dfDirectMotif['cluster'])
            '''
            scalar = StandardScaler()
            X_train = list(dfDirectMotif[category])
            scalar.fit(X_train)
            X_train = scalar.transform(X_train)
            X_test = scalar.transform(list(dfIVTMotif[category]))
            '''
                
            classifer = KNeighborsClassifier(n_neighbors=len(set(dfDirectMotif['cluster'])))
            classifer.fit(dfDirectMotif[category], dfDirectMotif['cluster'])


            predictedVals = list(classifer.predict(dfIVTMotif[category]))
            motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            #else:
            #   motifAccuracyModelDict[currentMotif] = -1  
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyMeanShift2(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyMeanShift2(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyDBSCAN2(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            dbscanCluster = DBSCAN(eps=0.25, min_samples=10)
            dfDirectMotif["cluster"] = dbscanCluster.fit_predict(dfDirectMotif[category])

            listOfClusterVals = list(dfDirectMotif['cluster'])
            actualIVTVal = max(listOfClusterVals, key = listOfClusterVals.count)
                
            classifer = KNeighborsClassifier(n_neighbors=len(set(dfDirectMotif['cluster'])))
            classifer.fit(dfDirectMotif[category], dfDirectMotif['cluster'])


            predictedVals = list(classifer.predict(dfIVTMotif[category]))
            motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)

        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyDBSCAN2(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyDBSCAN2(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyKMeansPrediction3(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            km = KMeans(n_clusters = 2)
            dfDirectMotif["cluster"] = km.fit_predict(dfDirectMotif[category])

            if len(set(dfDirectMotif['cluster'])) > 1:     
                classifer = KNeighborsClassifier(n_neighbors=2)
                classifer.fit(dfDirectMotif[category], dfDirectMotif['cluster'])


                predictedVals = list(classifer.predict(dfIVTMotif[category]))
                actualIVTVal = max(predictedVals, key = predictedVals.count)
                motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            else:
                motifAccuracyModelDict[currentMotif] = -2
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyKMeansPrediction3(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyKMeansPrediction3(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyMeanShift3(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            meansShift = MeanShift(bandwidth=1.0)
            dfDirectMotif["cluster"] = meansShift.fit_predict(dfDirectMotif[category])

            if len(set(dfDirectMotif['cluster'])) > 0:
                    
                classifer = KNeighborsClassifier(n_neighbors=len(set(dfDirectMotif['cluster'])))
                classifer.fit(dfDirectMotif[category], dfDirectMotif['cluster'])


                predictedVals = list(classifer.predict(dfIVTMotif[category]))
                actualIVTVal = max(predictedVals, key = predictedVals.count)
                motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            else:
               motifAccuracyModelDict[currentMotif] = -2  
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyMeanShift3(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyMeanShift3(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))

@ignore_warnings(category=ConvergenceWarning)
def UpdatedKmerPredictionAccuracyDBSCAN3(directRNADataFrame, ivtDataFrame, category):
    motifAccuracyModelDict = {}
    a = "ATGC"
    for eachMotif in itertools.product(a, repeat = 5):
        currentMotif = ''.join(eachMotif)
        dfDirectMotif = directRNADataFrame.loc[directRNADataFrame['reference_kmer'] == currentMotif]
        dfDirectMotif = dfDirectMotif.loc[dfDirectMotif['model_kmer'] != 'NNNNN']
        dfIVTMotif = ivtDataFrame.loc[ivtDataFrame['reference_kmer'] == currentMotif]
        dfIVTMotif = dfIVTMotif.loc[dfIVTMotif['model_kmer'] != 'NNNNN']
        if len(dfDirectMotif) > 1 and len(dfIVTMotif) > 1:
            dbscanCluster = DBSCAN(eps=0.25, min_samples=10)
            dfDirectMotif["cluster"] = dbscanCluster.fit_predict(dfDirectMotif[category])

            if len(set(dfDirectMotif['cluster'])) > 0:
                    
                classifer = KNeighborsClassifier(n_neighbors=len(set(dfDirectMotif['cluster'])))
                classifer.fit(dfDirectMotif[category], dfDirectMotif['cluster'])


                predictedVals = list(classifer.predict(dfIVTMotif[category]))
                actualIVTVal = max(predictedVals, key = predictedVals.count)
                motifAccuracyModelDict[currentMotif] = predictedVals.count(actualIVTVal)/len(predictedVals)
            else:
               motifAccuracyModelDict[currentMotif] = -2  
        else:
            motifAccuracyModelDict[currentMotif] = -1
    return motifAccuracyModelDict

categories = [category for category in dfDirect.keys()]
categories.remove("reference_kmer")
categories.remove("contig")
categories.remove("strand")
categories.remove("model_kmer")
categories.remove("standardized_level")
categories.remove("model_mean")
categories.remove("model_stdv")
accuracyCategoryDict = {}

for category in categories:
    category = [category]
    categoryDict = UpdatedKmerPredictionAccuracyDBSCAN3(dfDirect, dfIVT, category)
    accuracyCategoryDict[category[0]] = categoryDict
    print(category[0] + ":")
    print(categoryDict)

for category, motifAccuracies in accuracyCategoryDict.items():
    nonNegMotifAccuracies = [val for val in motifAccuracies.values() if val >= 0]
    if len(nonNegMotifAccuracies) > 0:
        print(category + ":" + str(mean(nonNegMotifAccuracies)))

correlationDict = {}
xValuesNumberPointsData = []
yValuesAccuracyGuess = []
a = "ATGC"
for eachMotif in itertools.product(a, repeat = 5):
    currentMotif = ''.join(eachMotif)
    correlationDict[currentMotif] = []
    for motifDictionaries in accuracyCategoryDict.values():
        if motifDictionaries[currentMotif] >= 0:
            correlationDict[currentMotif].append(motifDictionaries[currentMotif])   
    if len(correlationDict[currentMotif]) > 0:
        xValuesNumberPointsData.append(motifDataDictionary.get(currentMotif))
        yValuesAccuracyGuess.append(mean(correlationDict[currentMotif]))

plt.scatter(xValuesNumberPointsData, yValuesAccuracyGuess)
plt.title("Accuracy vs Data Points")
plt.xlabel("Data Points")
plt.ylabel("Accuracy")
plt.show()

completeCategoryDict = UpdatedKmerPredictionAccuracyDBSCAN3(dfDirect, dfIVT, categories)
nonNegCompleteAccuracies = [val for val in completeCategoryDict.values() if val >= 0]
print(str(mean(nonNegCompleteAccuracies)))



"""- New Classification Method
- Semi-supervised model
- Plot samples vs accuracy
"""